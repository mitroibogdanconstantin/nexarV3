import { createClient } from "@supabase/supabase-js";
import { v4 as uuidv4 } from "uuid";

// Creden»õialele Supabase pentru noua bazƒÉ de date
const supabaseUrl = "https://hwbiywnkrsdgbiakwjtv.supabase.co";
const supabaseAnonKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imh3Yml5d25rcnNkZ2JpYWt3anR2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTE0NjkzOTQsImV4cCI6MjA2NzA0NTM5NH0.DIWt1xS2XM9lWOrwAjIqVDvtOYBTuFILce5AbGjYfU8";

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
	auth: {
		autoRefreshToken: true,
		persistSession: true,
		detectSessionInUrl: true, // Pentru confirmarea emailului
		flowType: "pkce",
	},
});

// Tipuri pentru baza de date
export interface User {
	id: string;
	user_id: string; // ID-ul din auth.users
	name: string;
	email: string;
	phone?: string;
	location?: string;
	seller_type: "individual" | "dealer";
	avatar_url?: string;
	description?: string;
	website?: string;
	verified: boolean;
	is_admin: boolean;
	created_at: string;
	updated_at: string;
}

export interface Listing {
	id: string;
	title: string;
	price: number;
	year: number;
	mileage: number;
	location: string;
	category: string;
	brand: string;
	model: string;
	engine_capacity: number;
	fuel_type: string;
	transmission: string;
	condition: string;
	color: string;
	description: string;
	images: string[];
	features: string[];
	seller_id: string; // ID-ul din tabela users
	seller_name: string;
	seller_type: "individual" | "dealer";
	availability?: "pe_stoc" | "la_comanda"; // Doar pentru dealeri
	status: "pending" | "active" | "rejected" | "sold";
	views_count: number;
	created_at: string;
	updated_at: string;
}

// Lista ora»ôelor din Rom√¢nia
export const romanianCities = [
	"Bucure»ôti S1",
	"Bucure»ôti S2", 
	"Bucure»ôti S3",
	"Bucure»ôti S4",
	"Bucure»ôti S5",
	"Bucure»ôti S6",
	"Cluj-Napoca",
	"Timi»ôoara",
	"Ia»ôi",
	"Constan»õa",
	"Bra»ôov",
	"Craiova",
	"Gala»õi",
	"Oradea",
	"Ploie»ôti",
	"Sibiu",
	"BacƒÉu",
	"R√¢mnicu V√¢lcea",
	"Pite»ôti",
	"Arad",
	"Baia Mare",
	"BuzƒÉu",
	"Boto»ôani",
	"Satu Mare",
	"T√¢rgu Mure»ô",
	"Foc»ôani",
	"T√¢rgovi»ôte",
	"Deva",
	"Re»ôi»õa",
	"Alba Iulia",
	"Bistri»õa",
	"CƒÉlƒÉra»ôi",
	"Drobeta-Turnu Severin",
	"Hunedoara",
	"Piatra Neam»õ",
	"Roman",
	"Slatina",
	"Suceava",
	"Tulcea",
	"Vaslui",
	"ZalƒÉu"
];

// Func»õii pentru autentificare
export const auth = {
	signUp: async (email: string, password: string, userData: any) => {
		try {
			console.log("üöÄ √éncepe procesul de √Ænregistrare pentru:", email);

			const { data, error } = await supabase.auth.signUp({
				email,
				password,
				options: {
					data: userData,
					emailRedirectTo: `${window.location.origin}/auth/confirm`,
				},
			});

			if (error) {
				console.error("‚ùå Eroare la √Ænregistrare:", error);
				return { data, error };
			}

			console.log("‚úÖ Utilizator creat cu succes:", data.user?.email);
			return { data, error };
		} catch (err) {
			console.error("üí• Eroare la √Ænregistrare:", err);
			return { data: null, error: err };
		}
	},

	signIn: async (email: string, password: string) => {
		try {
			console.log("üîê √éncepe procesul de conectare pentru:", email);

			const { data, error } = await supabase.auth.signInWithPassword({
				email,
				password,
			});

			if (error) {
				console.error("‚ùå Eroare la conectare:", error);
				return { data, error };
			}

			console.log("‚úÖ Utilizator conectat cu succes:", data.user?.email);
			return { data, error };
		} catch (err) {
			console.error("üí• Eroare la conectare:", err);
			return { data: null, error: err };
		}
	},

	signOut: async () => {
		console.log("üëã Deconectare utilizator...");
		localStorage.removeItem("user");

		try {
			const { error } = await supabase.auth.signOut();
			
			if (error) {
				console.error("‚ùå Eroare la deconectare:", error);
			}

			// Re√ÆncƒÉrcƒÉm pagina pentru a curƒÉ»õa starea
			setTimeout(() => {
				window.location.reload();
			}, 100);

			return { error };
		} catch (err) {
			console.error("üí• Eroare la deconectare:", err);
			localStorage.clear();
			sessionStorage.clear();
			return { error: err };
		}
	},

	getCurrentUser: async () => {
		try {
			const { data: { user }, error } = await supabase.auth.getUser();

			if (error) {
				console.error("‚ùå Eroare la ob»õinerea utilizatorului curent:", error);
				return null;
			}

			return user;
		} catch (err) {
			console.error("üí• Eroare la ob»õinerea utilizatorului curent:", err);
			return null;
		}
	},

	resetPassword: async (email: string) => {
		console.log("üîë Trimitere email pentru resetarea parolei cƒÉtre:", email);

		try {
			const { data, error } = await supabase.auth.resetPasswordForEmail(email, {
				redirectTo: `${window.location.origin}/auth/reset-password`,
			});

			if (error) {
				console.error("‚ùå Eroare la trimiterea emailului de resetare:", error);
				return { data: null, error };
			}

			console.log("‚úÖ Email de resetare trimis cu succes");
			return { data, error: null };
		} catch (err) {
			console.error("üí• Eroare la trimiterea emailului de resetare:", err);
			return { data: null, error: err };
		}
	},

	updatePassword: async (newPassword: string) => {
		try {
			console.log("üîê Actualizare parolƒÉ...");

			const { data, error } = await supabase.auth.updateUser({
				password: newPassword,
			});

			if (error) {
				console.error("‚ùå Eroare la actualizarea parolei:", error);
				return { data: null, error };
			}

			console.log("‚úÖ ParolƒÉ actualizatƒÉ cu succes");
			return { data, error: null };
		} catch (err) {
			console.error("üí• Eroare la actualizarea parolei:", err);
			return { data: null, error: err };
		}
	},
};

// Func»õii pentru utilizatori
export const users = {
	getById: async (userId: string) => {
		try {
			const { data, error } = await supabase
				.from("users")
				.select("*")
				.eq("user_id", userId)
				.single();

			return { data, error };
		} catch (err) {
			console.error("Eroare la ob»õinerea utilizatorului:", err);
			return { data: null, error: err };
		}
	},

	update: async (userId: string, updates: Partial<User>) => {
		try {
			const { data, error } = await supabase
				.from("users")
				.update({
					...updates,
					updated_at: new Date().toISOString(),
				})
				.eq("user_id", userId)
				.select();

			return { data, error };
		} catch (err) {
			console.error("Eroare la actualizarea utilizatorului:", err);
			return { data: null, error: err };
		}
	},

	uploadAvatar: async (userId: string, file: File) => {
		try {
			const fileExt = file.name.split(".").pop();
			const fileName = `${uuidv4()}.${fileExt}`;
			const filePath = `${userId}/${fileName}`;

			const { error: uploadError } = await supabase.storage
				.from("profile-images")
				.upload(filePath, file);

			if (uploadError) {
				return { error: uploadError };
			}

			// Ob»õinem URL-ul public pentru avatar
			const { data: { publicUrl } } = supabase.storage
				.from("profile-images")
				.getPublicUrl(filePath);

			// ActualizƒÉm utilizatorul cu noul avatar
			const { data, error } = await supabase
				.from("users")
				.update({ avatar_url: publicUrl })
				.eq("user_id", userId)
				.select();

			return { data, error };
		} catch (err) {
			console.error("Eroare la √ÆncƒÉrcarea avatarului:", err);
			return { data: null, error: err };
		}
	},
};

// Func»õii pentru anun»õuri
export const listings = {
	getAll: async (filters?: any) => {
		try {
			console.log("üîç Ob»õinere toate anun»õurile din Supabase...");

			let query = supabase
				.from("listings")
				.select("*")
				.eq("status", "active")
				.order("created_at", { ascending: false });

			if (filters) {
				if (filters.category) query = query.eq("category", filters.category.toLowerCase());
				if (filters.brand) query = query.eq("brand", filters.brand);
				if (filters.priceMin) query = query.gte("price", filters.priceMin);
				if (filters.priceMax) query = query.lte("price", filters.priceMax);
				if (filters.yearMin) query = query.gte("year", filters.yearMin);
				if (filters.yearMax) query = query.lte("year", filters.yearMax);
				if (filters.location) query = query.ilike("location", `%${filters.location}%`);
				if (filters.sellerType) query = query.eq("seller_type", filters.sellerType);
				if (filters.condition) query = query.eq("condition", filters.condition);
				if (filters.fuel) query = query.eq("fuel_type", filters.fuel);
				if (filters.transmission) query = query.eq("transmission", filters.transmission);
				if (filters.engineMin) query = query.gte("engine_capacity", filters.engineMin);
				if (filters.engineMax) query = query.lte("engine_capacity", filters.engineMax);
				if (filters.mileageMax) query = query.lte("mileage", filters.mileageMax);
				if (filters.availability) query = query.eq("availability", filters.availability);
			}

			const { data, error } = await query;

			if (error) {
				console.error("‚ùå Eroare la ob»õinerea anun»õurilor:", error);
				return { data: null, error };
			}

			console.log(`‚úÖ S-au ob»õinut cu succes ${data?.length || 0} anun»õuri`);
			return { data, error: null };
		} catch (err) {
			console.error("üí• Eroare √Æn listings.getAll:", err);
			return { data: null, error: err };
		}
	},

	getUserListings: async (userId: string) => {
		try {
			console.log("üîç Ob»õinere anun»õuri utilizator din Supabase...");

			// Ob»õinem utilizatorul pentru a avea seller_id
			const { data: user, error: userError } = await supabase
				.from("users")
				.select("id")
				.eq("user_id", userId)
				.single();

			if (userError || !user) {
				console.error("‚ùå Eroare la ob»õinerea utilizatorului:", userError);
				return { data: null, error: userError || new Error("Utilizatorul nu a fost gƒÉsit") };
			}

			// Ob»õinem toate anun»õurile utilizatorului
			const { data, error } = await supabase
				.from("listings")
				.select("*")
				.eq("seller_id", user.id)
				.order("created_at", { ascending: false });

			if (error) {
				console.error("‚ùå Eroare la ob»õinerea anun»õurilor utilizatorului:", error);
				return { data: null, error };
			}

			console.log(`‚úÖ S-au ob»õinut cu succes ${data?.length || 0} anun»õuri ale utilizatorului`);
			return { data, error: null };
		} catch (err) {
			console.error("üí• Eroare √Æn listings.getUserListings:", err);
			return { data: null, error: err };
		}
	},

	getById: async (id: string) => {
		try {
			const { data, error } = await supabase
				.from("listings")
				.select("*")
				.eq("id", id)
				.single();

			// IncrementƒÉm numƒÉrul de vizualizƒÉri
			if (data && !error) {
				await supabase
					.from("listings")
					.update({ views_count: (data.views_count || 0) + 1 })
					.eq("id", id);
			}

			return { data, error };
		} catch (err) {
			console.error("Eroare la ob»õinerea anun»õului:", err);
			return { data: null, error: err };
		}
	},

	create: async (listing: Partial<Listing>, images: File[]) => {
		try {
			console.log("üöÄ √éncepe procesul de creare anun»õ...");

			// 1. Ob»õinem utilizatorul curent
			const { data: { user } } = await supabase.auth.getUser();
			if (!user) {
				throw new Error("Utilizatorul nu este autentificat");
			}

			console.log("üë§ Utilizator curent:", user.email);

			// 2. Ob»õinem profilul utilizatorului
			const { data: userProfile, error: userError } = await supabase
				.from("users")
				.select("id, name, seller_type")
				.eq("user_id", user.id)
				.single();

			if (userError || !userProfile) {
				console.error("‚ùå Profil negƒÉsit:", userError);
				throw new Error("Profilul utilizatorului nu a fost gƒÉsit. Te rugƒÉm sƒÉ-»õi completezi profilul mai √Ænt√¢i.");
			}

			console.log("‚úÖ Profil gƒÉsit:", userProfile);

			// 3. √éncƒÉrcƒÉm imaginile √Æn storage (dacƒÉ existƒÉ)
			const imageUrls: string[] = [];

			if (images && images.length > 0) {
				console.log(`üì∏ √éncƒÉrcare ${images.length} imagini...`);

				for (const image of images) {
					const fileExt = image.name.split(".").pop();
					const fileName = `${uuidv4()}.${fileExt}`;
					const filePath = `${userProfile.id}/${fileName}`;

					console.log(`üì§ √éncƒÉrcare imagine: ${fileName}`);

					const { error: uploadError, data: uploadData } = await supabase.storage
						.from("listing-images")
						.upload(filePath, image, {
							cacheControl: "3600",
							upsert: false,
						});

					if (uploadError) {
						console.error("‚ùå Eroare la √ÆncƒÉrcarea imaginii:", uploadError);
						continue;
					}

					console.log("‚úÖ Imagine √ÆncƒÉrcatƒÉ:", uploadData.path);

					// Ob»õinem URL-ul public pentru imagine
					const { data: { publicUrl } } = supabase.storage
						.from("listing-images")
						.getPublicUrl(filePath);

					console.log("üîó URL public:", publicUrl);
					imageUrls.push(publicUrl);
				}

				console.log(`‚úÖ S-au √ÆncƒÉrcat cu succes ${imageUrls.length} imagini`);
			}

			// 4. PregƒÉtim datele pentru anun»õ
			const listingData = {
				...listing,
				id: uuidv4(),
				seller_id: userProfile.id,
				seller_name: userProfile.name,
				seller_type: userProfile.seller_type,
				images: imageUrls,
				status: "pending", // Toate anun»õurile √Æncep √Æn a»ôteptare
				views_count: 0,
			};

			console.log("üìù Creare anun»õ cu datele:", {
				...listingData,
				images: `${imageUrls.length} imagini`,
			});

			// 5. CreƒÉm anun»õul √Æn baza de date
			const { data, error } = await supabase
				.from("listings")
				.insert([listingData])
				.select()
				.single();

			if (error) {
				console.error("‚ùå Eroare la crearea anun»õului:", error);
				throw new Error(`Eroare la crearea anun»õului: ${error.message}`);
			}

			console.log("‚úÖ Anun»õ creat cu succes:", data.id);
			return { data, error: null };
		} catch (err: any) {
			console.error("üí• Eroare √Æn listings.create:", err);
			return { data: null, error: err };
		}
	},

	update: async (id: string, updates: Partial<Listing>, newImages?: File[], imagesToRemove?: string[]) => {
		try {
			console.log("üîÑ √éncepe procesul de actualizare anun»õ...");

			// 1. Ob»õinem anun»õul curent
			const { data: currentListing, error: fetchError } = await supabase
				.from("listings")
				.select("images, seller_id, seller_name, status, seller_type, availability")
				.eq("id", id)
				.single();

			if (fetchError || !currentListing) {
				console.error("‚ùå Eroare la ob»õinerea anun»õului curent:", fetchError);
				throw new Error(`Eroare la ob»õinerea anun»õului: ${fetchError?.message || "Anun»õul nu a fost gƒÉsit"}`);
			}

			// 2. GestionƒÉm imaginile
			let updatedImages = [...(currentListing.images || [])];

			// 2.1 »òtergem imaginile marcate pentru eliminare
			if (imagesToRemove && imagesToRemove.length > 0) {
				console.log(`üóëÔ∏è Eliminare ${imagesToRemove.length} imagini...`);
				updatedImages = updatedImages.filter(img => !imagesToRemove.includes(img));

				// √éncercƒÉm sƒÉ »ôtergem »ôi din storage
				for (const imageUrl of imagesToRemove) {
					try {
						const urlParts = imageUrl.split("/");
						const fileName = urlParts[urlParts.length - 1];
						const sellerFolder = urlParts[urlParts.length - 2];
						const filePath = `${sellerFolder}/${fileName}`;

						await supabase.storage.from("listing-images").remove([filePath]);
						console.log(`‚úÖ Imagine eliminatƒÉ din storage: ${filePath}`);
					} catch (removeError) {
						console.error("‚ö†Ô∏è Eroare la eliminarea imaginii din storage:", removeError);
					}
				}
			}

			// 2.2 AdƒÉugƒÉm imaginile noi
			if (newImages && newImages.length > 0) {
				console.log(`üì∏ √éncƒÉrcare ${newImages.length} imagini noi...`);

				for (const image of newImages) {
					const fileExt = image.name.split(".").pop();
					const fileName = `${uuidv4()}.${fileExt}`;
					const filePath = `${currentListing.seller_id}/${fileName}`;

					console.log(`üì§ √éncƒÉrcare imagine: ${fileName}`);

					const { error: uploadError, data: uploadData } = await supabase.storage
						.from("listing-images")
						.upload(filePath, image, {
							cacheControl: "3600",
							upsert: false,
						});

					if (uploadError) {
						console.error("‚ùå Eroare la √ÆncƒÉrcarea imaginii:", uploadError);
						continue;
					}

					console.log("‚úÖ Imagine √ÆncƒÉrcatƒÉ:", uploadData.path);

					const { data: { publicUrl } } = supabase.storage
						.from("listing-images")
						.getPublicUrl(filePath);

					console.log("üîó URL public:", publicUrl);
					updatedImages.push(publicUrl);
				}
			}

			// 3. ActualizƒÉm anun»õul
			const updateData = {
				...updates,
				images: updatedImages,
				updated_at: new Date().toISOString(),
				status: "pending", // Orice modificare pune anun»õul √Ænapoi √Æn a»ôteptare
			};

			console.log("üìù Actualizare anun»õ cu datele:", {
				...updateData,
				images: `${updatedImages.length} imagini`,
			});

			const { data, error } = await supabase
				.from("listings")
				.update(updateData)
				.eq("id", id)
				.select();

			if (error) {
				console.error("‚ùå Eroare la actualizarea anun»õului:", error);
				throw new Error(`Eroare la actualizarea anun»õului: ${error.message}`);
			}

			console.log("‚úÖ Anun»õ actualizat cu succes:", id);
			return { data, error: null };
		} catch (error: any) {
			console.error("üí• Eroare √Æn listings.update:", error);
			return { data: null, error: error };
		}
	},

	delete: async (id: string) => {
		try {
			// Ob»õinem anun»õul pentru a »ôterge imaginile
			const { data: listing } = await supabase
				.from("listings")
				.select("images")
				.eq("id", id)
				.single();

			// »òtergem imaginile din storage
			if (listing && listing.images) {
				for (const imageUrl of listing.images) {
					try {
						const urlParts = imageUrl.split("/");
						const fileName = urlParts[urlParts.length - 1];
						const sellerFolder = urlParts[urlParts.length - 2];
						const filePath = `${sellerFolder}/${fileName}`;

						await supabase.storage.from("listing-images").remove([filePath]);
						console.log(`‚úÖ Imagine eliminatƒÉ din storage: ${filePath}`);
					} catch (error) {
						console.error("Eroare la eliminarea imaginii:", error);
					}
				}
			}

			// »òtergem anun»õul
			const { error } = await supabase.from("listings").delete().eq("id", id);
			return { error };
		} catch (err) {
			console.error("Eroare la »ôtergerea anun»õului:", err);
			return { error: err };
		}
	},
};

// Func»õii pentru admin
export const admin = {
	isAdmin: async () => {
		try {
			console.log("üîç Verificare status admin...");

			// VerificƒÉm dacƒÉ existƒÉ un utilizator √Æn localStorage
			const userStr = localStorage.getItem("user");
			if (userStr) {
				try {
					const user = JSON.parse(userStr);
					if (user && user.isAdmin) {
						console.log("‚úÖ Utilizatorul este admin conform localStorage");
						return true;
					}
				} catch (e) {
					console.error("Eroare la parsarea utilizatorului din localStorage:", e);
				}
			}

			const { data: { user } } = await supabase.auth.getUser();

			if (!user) {
				console.log("‚ùå Niciun utilizator autentificat");
				return false;
			}

			console.log("üë§ Verificare status admin pentru utilizatorul:", user.email);

			// Verificare simplƒÉ: dacƒÉ email-ul este admin@nexar.ro, este admin
			if (user.email === "admin@nexar.ro") {
				console.log("‚úÖ Utilizatorul este admin conform email-ului");
				return true;
			}

			// √éncercƒÉm sƒÉ verificƒÉm √Æn baza de date
			try {
				const { data: userProfile, error: profileError } = await supabase
					.from("users")
					.select("is_admin")
					.eq("user_id", user.id)
					.single();

				if (!profileError && userProfile) {
					console.log("‚úÖ Profil gƒÉsit, is_admin:", userProfile.is_admin);
					return userProfile.is_admin || false;
				} else {
					console.log("‚ö†Ô∏è Profil negƒÉsit sau eroare:", profileError);
					return user.email === "admin@nexar.ro";
				}
			} catch (profileError) {
				console.error("‚ö†Ô∏è Eroare la verificarea profilului, folosim fallback email:", profileError);
				return user.email === "admin@nexar.ro";
			}
		} catch (err) {
			console.error("üí• Eroare la verificarea statusului de admin:", err);
			return false;
		}
	},

	getAllListings: async () => {
		try {
			console.log("üîç Ob»õinere TOATE anun»õurile pentru admin...");

			const { data, error } = await supabase
				.from("listings")
				.select(`
					*,
					users!listings_seller_id_fkey (
						name,
						email,
						seller_type,
						verified
					)
				`)
				.order("created_at", { ascending: false });

			if (error) {
				console.error("‚ùå Eroare la ob»õinerea anun»õurilor admin:", error);
				return { data: null, error };
			}

			console.log(`‚úÖ S-au ob»õinut cu succes ${data?.length || 0} anun»õuri pentru admin`);
			return { data, error: null };
		} catch (err) {
			console.error("üí• Eroare √Æn admin.getAllListings:", err);
			return { data: null, error: err };
		}
	},

	updateListingStatus: async (listingId: string, status: string) => {
		try {
			console.log("üìù Actualizare status anun»õ:", listingId, "la", status);

			const { data, error } = await supabase
				.from("listings")
				.update({ status })
				.eq("id", listingId)
				.select();

			if (error) {
				console.error("‚ùå Eroare la actualizarea statusului anun»õului:", error);
				return { data: null, error };
			}

			console.log("‚úÖ Status anun»õ actualizat cu succes");
			return { data, error: null };
		} catch (err) {
			console.error("üí• Eroare √Æn updateListingStatus:", err);
			return { data: null, error: err };
		}
	},

	deleteListing: async (listingId: string) => {
		try {
			console.log("üóëÔ∏è »òtergere anun»õ:", listingId);

			// Ob»õinem anun»õul pentru a »ôterge imaginile
			const { data: listing } = await supabase
				.from("listings")
				.select("images")
				.eq("id", listingId)
				.single();

			// »òtergem imaginile din storage
			if (listing && listing.images) {
				for (const imageUrl of listing.images) {
					try {
						const urlParts = imageUrl.split("/");
						const fileName = urlParts[urlParts.length - 1];
						const sellerFolder = urlParts[urlParts.length - 2];
						const filePath = `${sellerFolder}/${fileName}`;

						await supabase.storage.from("listing-images").remove([filePath]);
						console.log(`‚úÖ Imagine eliminatƒÉ din storage: ${filePath}`);
					} catch (error) {
						console.error("Eroare la eliminarea imaginii:", error);
					}
				}
			}

			// »òtergem anun»õul
			const { error } = await supabase
				.from("listings")
				.delete()
				.eq("id", listingId);

			if (error) {
				console.error("‚ùå Eroare la »ôtergerea anun»õului:", error);
				return { error };
			}

			console.log("‚úÖ Anun»õ »ôters cu succes");
			return { error: null };
		} catch (err) {
			console.error("üí• Eroare √Æn deleteListing:", err);
			return { error: err };
		}
	},

	getAllUsers: async () => {
		try {
			const { data, error } = await supabase
				.from("users")
				.select("*")
				.order("created_at", { ascending: false });

			return { data, error };
		} catch (err) {
			console.error("Eroare la ob»õinerea utilizatorilor:", err);
			return { data: null, error: err };
		}
	},

	toggleUserStatus: async (userId: string, suspended: boolean) => {
		try {
			const { data, error } = await supabase
				.from("users")
				.update({ suspended })
				.eq("user_id", userId)
				.select();

			return { data, error };
		} catch (err) {
			console.error("Eroare la schimbarea statusului utilizatorului:", err);
			return { data: null, error: err };
		}
	},
};

// Func»õie pentru a verifica dacƒÉ utilizatorul este autentificat
export const isAuthenticated = async () => {
	try {
		const { data: { user } } = await supabase.auth.getUser();
		return !!user;
	} catch (err) {
		console.error("Eroare la verificarea autentificƒÉrii:", err);
		return false;
	}
};

// Func»õie pentru a verifica dacƒÉ Supabase este configurat corect
export const checkSupabaseConnection = async () => {
	try {
		const { error } = await supabase
			.from("users")
			.select("count", { count: "exact", head: true });
		return !error;
	} catch (e) {
		console.error("Eroare de conexiune Supabase:", e);
		return false;
	}
};

// Func»õie pentru testarea conexiunii complete
export const testConnection = async () => {
	try {
		console.log("üîç Testare conexiune Supabase...");

		// Test 1: Conexiunea de bazƒÉ
		const { data: healthCheck, error: healthError } = await supabase
			.from("users")
			.select("count", { count: "exact", head: true });

		if (healthError) {
			console.error("‚ùå Verificarea de sƒÉnƒÉtate a e»ôuat:", healthError);
			return { success: false, error: "Conexiunea la baza de date a e»ôuat" };
		}

		console.log("‚úÖ Conexiunea la baza de date reu»ôitƒÉ");

		// Test 2: VerificƒÉm tabelele
		const tables = ["users", "listings"];
		for (const table of tables) {
			const { error } = await supabase
				.from(table)
				.select("count", { count: "exact", head: true });

			if (error) {
				console.error(`‚ùå Tabela ${table} nu a fost gƒÉsitƒÉ:`, error);
				return { success: false, error: `Tabela ${table} lipse»ôte` };
			}
			console.log(`‚úÖ Tabela ${table} existƒÉ`);
		}

		console.log("üéâ Testul de conexiune finalizat cu succes!");
		return {
			success: true,
			message: "Testul de conexiune finalizat - verificƒÉ consola pentru detalii",
		};
	} catch (err) {
		console.error("‚ùå Testul de conexiune a e»ôuat:", err);
		return { success: false, error: "Eroare nea»ôteptatƒÉ √Æn timpul testƒÉrii" };
	}
};